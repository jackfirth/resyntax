#lang racket/base


(require racket/contract/base)


(provide
 (contract-out
  [refactoring-result? predicate/c]
  [refactoring-result
   (-> #:source source?
       #:rule-name interned-symbol?
       #:message string?
       #:replacement syntax-replacement?
       refactoring-result?)]
  [refactoring-result-source (-> refactoring-result? source?)]
  [refactoring-result-rule-name (-> refactoring-result? interned-symbol?)]
  [refactoring-result-message (-> refactoring-result? immutable-string?)]
  [refactoring-result-modified-range (-> refactoring-result? range?)]
  [refactoring-result-replacement (-> refactoring-result? syntax-replacement?)]
  [refactoring-result-string-replacement (-> refactoring-result? string-replacement?)]
  [refactoring-result-line-replacement (-> refactoring-result? line-replacement?)]
  [refactoring-result-original-line (-> refactoring-result? exact-positive-integer?)]
  [refactoring-result-original-code (-> refactoring-result? code-snippet?)]
  [refactoring-result-new-code (-> refactoring-result? code-snippet?)]))


(require fancy-app
         fmt
         framework
         (only-in racket/class
                  new
                  send)
         racket/pretty
         racket/string
         rebellion/base/immutable-string
         rebellion/base/range
         rebellion/base/symbol
         rebellion/type/record
         resyntax/private/code-snippet
         resyntax/private/line-replacement
         resyntax/private/linemap
         resyntax/private/source
         resyntax/private/string-indent
         resyntax/private/string-replacement
         resyntax/private/syntax-range
         resyntax/private/syntax-replacement)


;@----------------------------------------------------------------------------------------------------


(define-record-type refactoring-result (source rule-name message replacement)
  #:omit-root-binding)


(define (refactoring-result
         #:source source #:rule-name rule-name #:message message #:replacement replacement)
  (constructor:refactoring-result
   #:source source
   #:rule-name rule-name
   #:message (string->immutable-string message)
   #:replacement replacement))


(define (refactoring-result-modified-range result)
  (syntax-source-range (syntax-replacement-original-syntax (refactoring-result-replacement result))))


(define (refactoring-result-original-position result)
  (define original (syntax-replacement-original-syntax (refactoring-result-replacement result)))
  (sub1 (syntax-position original)))


(define (refactoring-result-original-line result)
  (syntax-line (syntax-replacement-original-syntax (refactoring-result-replacement result))))


(define (refactoring-result-original-code result)
  (define original (syntax-replacement-original-syntax (refactoring-result-replacement result)))
  (define start (sub1 (syntax-position original)))
  (define end (+ start (syntax-span original)))
  (define start-column (syntax-column original))
  (define raw-text
    (string->immutable-string
     (substring (source->string (refactoring-result-source result)) start end)))
  (code-snippet raw-text start-column (syntax-line original)))


;; This exception is thrown when Resyntax detects that the fmt autoformatter modified code that it
;; shouldn't have touched.
(struct exn:fail:refactoring-formatting-out-of-bounds exn:fail
  (refactored-code formatted-code start end)
  #:transparent)


;; This is basically just a string slice, or a substring view. It holds a string and indices pointing
;; to the start and end of a substring within that string. Currently this is only used in this file to
;; keep track of how the end index of a source code range changes when that range is formatted.
(struct formatted-code-subrange (full-source-code subrange-start subrange-end) #:transparent)


(define (formatted-code-subrange-source-code subrange)
  (substring (formatted-code-subrange-full-source-code subrange)
             (formatted-code-subrange-subrange-start subrange)
             (formatted-code-subrange-subrange-end subrange)))


;; This function is the sole integration point between Resyntax and fmt. It is used by Resyntax to
;; format any refactored code initially generated by Resyntax.
(define (format-refactored-code refactored-source-code #:start start #:end end)
  ;; TODO: actually use start and end to format only that range once fmt supports it.
  (define formatted-source-code
    ;; Appending a newline is needed because fmt strips the trailing newline from files for some
    ;; reason.
    (string-append (program-format refactored-source-code) "\n"))

  ;; Formatting can change the total length of the program source code, and we want to tell the
  ;; caller where the new endpoint of the formatted source range is.
  (define formatting-delta
    (- (string-length formatted-source-code) (string-length refactored-source-code)))
  (define end-after-formatting (+ end formatting-delta))

  ;; Before handing the reformatted code back to the caller, we double check that fmt didn't touch
  ;; anything outside the requested range. If it did, raise an exception with an error message that
  ;; explains the problem and includes the code both before and after formatting.
  (unless (and (equal? (substring refactored-source-code 0 start)
                       (substring formatted-source-code 0 start))
               (equal? (substring refactored-source-code end)
                       (substring formatted-source-code end-after-formatting)))
    (raise
     (exn:fail:refactoring-formatting-out-of-bounds
      (string-append "format-refactored-code: failed to format refactored code;\n"
                     " fmt edited other code outside the target source code range\n"
                     (format "  code before formatting:\n~a\n"
                             (string-indent refactored-source-code #:amount 3))
                     (format "  code after formatting:\n~a\n"
                             (string-indent formatted-source-code #:amount 3))
                     (format "  target source range: [~a, ~a)" start end))
      (current-continuation-marks)
      refactored-source-code
      formatted-source-code
      start
      end)))

  (formatted-code-subrange formatted-source-code start end-after-formatting))


;; Translates a refactoring result (which soletly describes an AST-level syntax object replacement)
;; into string replacement which can be applied directly to the actual source code string. This
;; function touches only the exact subexpression identified by the replaced syntax object. It's used
;; by Resyntax when actually modifying files with the `resyntax fix` command. Analysis and review
;; comments however must use the function refactoring-result-line-replacement which is slightly
;; different to avoid conflicts between technically independent refactoring results on the same line.
(define (refactoring-result-string-replacement result)
  (define old-start (refactoring-result-original-position result))
  (define old-code (code-snippet-raw-text (refactoring-result-original-code result)))
  (define new-code (code-snippet-raw-text (refactoring-result-new-code result)))
  (define old-end (+ old-start (string-length old-code)))
  (string-replacement
   #:start old-start
   #:end old-end
   #:contents (list (inserted-string new-code))))


(define (refactoring-result-new-code result)
  (define original (syntax-replacement-original-syntax (refactoring-result-replacement result)))
  (define original-line (syntax-line original))
  (define original-column (syntax-column original))
  (define start (sub1 (syntax-position original)))
  (define replacement (syntax-replacement-render (refactoring-result-replacement result)))
  (define end (+ start (string-replacement-new-span replacement)))
  (define source-code (source->string (refactoring-result-source result)))
  (define refactored-source-code (string-apply-replacement source-code replacement))
  (define formatted-source-code
    (format-refactored-code refactored-source-code #:start start #:end end))
  (define new-code-string (formatted-code-subrange-source-code formatted-source-code))
  (code-snippet new-code-string original-column original-line))


;; Like refactoring-result-string-replacement, but for generating a source code replacement across a
;; range of lines in the source code text rather than exact positions. This is used by Resyntax when
;; it is necessary to avoid conflicts between technically independent refactoring results whose lines
;; overlap, which can cause problems in various UIs. GitHub pull request comments, for instance, are
;; not pleasant to read when there are multiple independent comment threads on the same line of code.
;; When Resyntax actually fixes files directly via the `resyntax fix` command, the more precise
;; refactoring-result-string-replacement function is used instead because the results do not have to
;; be displayed in a UI.
(define (refactoring-result-line-replacement result)
  (line-replacement
   #:start-line
   (syntax-line (syntax-replacement-original-syntax (refactoring-result-replacement result)))
   #:original-lines (refactoring-result-original-code-lines result)
   #:new-lines (refactoring-result-new-code-lines result)))


(define (refactoring-result-original-code-lines result)
  (define source-code (source->string (refactoring-result-source result)))
  (define map (string-linemap source-code))
  (define original (syntax-replacement-original-syntax (refactoring-result-replacement result)))
  (define start (syntax-start-line-position original #:linemap map))
  (define end (syntax-end-line-position original #:linemap map))
  (define original-text (string->immutable-string (substring source-code (sub1 start) (sub1 end))))
  (in-lines (open-input-string original-text)))


(define (refactoring-result-new-code-lines result)
  (define original (syntax-replacement-original-syntax (refactoring-result-replacement result)))
  (define start (syntax-position original))
  (define replacement (syntax-replacement-render (refactoring-result-replacement result)))
  (define end (+ start (string-replacement-new-span replacement)))
  (define source-code (source->string (refactoring-result-source result)))
  (define refactored-source-code (string-apply-replacement source-code replacement))

  ;; TODO: update this to use fmt instead of drracket, like in refactoring-result-string-replacement.
  (define text-object (new racket:text%))
  (send text-object insert refactored-source-code)
  (send text-object set-position (sub1 start) (sub1 end))
  (send text-object tabify-all)
  (define indented-start (add1 (send text-object get-start-position)))
  (define indented-end (add1 (send text-object get-end-position)))
  (define all-indented-raw-text (string->immutable-string (send text-object get-text)))

  (define map (string-linemap all-indented-raw-text))
  (define replacement-text
    (string->immutable-string
     (substring all-indented-raw-text
                (sub1 (linemap-position-to-start-of-line map indented-start))
                (sub1 (linemap-position-to-end-of-line map indented-end)))))
  (in-lines (open-input-string replacement-text)))
